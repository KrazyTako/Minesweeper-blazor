@page "/"
@inject VibrationService vibrationService

<div class="container">
    <h1>@message</h1>

    <p>Remaining mines: @remainingMines</p>
    <p>Elapsed time: @elapsedTime</p>

    @for (int i = 0; i < tiles.Length; i++)
    {
        int row = i;
        <div class="row flex-nowrap" oncontextmenu="return false" style="-moz-user-select: none; -webkit-user-select: none; -ms-user-select: none; user-select: none; -o-user-select: none;">
            @for (int j = 0; j < tiles[i].Length; j++)
            {
                int col = j;
                TileProperty tile = tiles[i][j];
                <div class="col" @ontouchstart="TouchStart" @ontouchend="(e) => TouchEnd(e, tile)" @onmouseup="(e) => OnClick(e, tile)" style="background-color:@tile.BackgroundColor; border:solid 1px; min-height:35px; min-width:25px; text-align:center">
                    <span class="@tile.cssIcon"></span>
                    @(tile.IsRevealed && string.IsNullOrEmpty(tile.cssIcon) ? (tile.SurroundingCount == 0 ? "" : tile.SurroundingCount.ToString()) : "")
                </div>
            }
        </div>
    }

    <EditForm Model="gridSize" class="form-inline my-3">
        <div class="form-group mr-2">
            <label class="mr-2" for="gridSize">Grid size</label>
            <InputNumber id="gridSize" class="form-control" @bind-Value="gridSize" min="5" max="20"></InputNumber>
        </div>
        <div class="form-group mr-2">
            <label class="mr-2" for="mineCount">Mine Count</label>
            <InputNumber id="mineCount" class="form-control" @bind-Value="totalMines" min="1" max="@(gridSize * gridSize - 1)"></InputNumber>
        </div>
        <button type="button" @onclick="Reset" class="btn btn-outline-primary">Reset</button>
    </EditForm>
     <MineSweeperWeb.Pages.Components.ScoreBoard></MineSweeperWeb.Pages.Components.ScoreBoard>
</div>

@code {
    private int gridSize = 8;
    private int totalMines = 10;
    private int remainingMines;
    private bool gameOver = false;
    private bool firstTouch = true;
    private string elapsedTime;
    private int revealedSuccess;
    private int revealedToWin;
    private string message;
    private bool lastEventWasTouch;

    private TileProperty[][] tiles;
    private Random generator = new Random();
    private System.Diagnostics.Stopwatch stopwatch = new System.Diagnostics.Stopwatch();
    private System.Diagnostics.Stopwatch longPressWatch = new System.Diagnostics.Stopwatch();
    private System.Timers.Timer timer = new System.Timers.Timer(200);

    protected override void OnInitialized()
    {
        base.OnInitialized();
        Reset();
        timer.Elapsed += doVibration;
        StartTimer();
    }

    private void Reset()
    {
        gameOver = false;
        firstTouch = true;
        stopwatch.Stop();
        remainingMines = totalMines;
        elapsedTime = "0";
        revealedSuccess = 0;
        revealedToWin = (gridSize * gridSize) - totalMines;
        message = "You got this!";

        tiles = new TileProperty[gridSize][];
        for (int i = 0; i < tiles.Length; i++)
        {
            tiles[i] = new TileProperty[gridSize];
            for (int j = 0; j < tiles[i].Length; j++)
            {
                tiles[i][j] = new TileProperty();
                tiles[i][j].Row = i;
                tiles[i][j].Col = j;
            }
        }

        int count = 0;
        while (count < totalMines)
        {
            int randomRow = generator.Next(0, gridSize);
            int randomCol = generator.Next(0, gridSize);
            TileProperty tile = tiles[randomRow][randomCol];

            if (!tile.IsBomb)
            {
                tile.IsBomb = true;
                count++;
            }
        }

        for (int i = 0; i < tiles.Length; i++)
        {
            for (int j = 0; j < tiles[i].Length; j++)
            {
                var tile = tiles[i][j];
                tile.SurroundingCount = CountNeighboringBombs(tile);
            }
        }
    }

    private async Task StartTimer()
    {
        while (true)
        {
            await Task.Delay(1000);
            if (stopwatch.IsRunning)
            {
                elapsedTime = Math.Round(stopwatch.ElapsedMilliseconds / 1000.0).ToString() ;
                StateHasChanged();
            }
        }
    }


    private void TouchStart(TouchEventArgs e)
    {
        Console.WriteLine("Touch Started");
        longPressWatch.Restart();
        lastEventWasTouch = true;
        timer.Start();
    }

    private void doVibration(Object source, System.Timers.ElapsedEventArgs e)
    {
        vibrationService.VibrateAsync(100);
        timer.Stop();
    }

    private async Task TouchEnd(TouchEventArgs e, TileProperty tile)
    {
        timer.Stop();
        longPressWatch.Stop();
        Console.WriteLine("Touch hold lasted: {0}", longPressWatch.ElapsedMilliseconds);
        if (gameOver || tile.IsRevealed)
        {
            return;
        }
        if (firstTouch)
        {
            firstTouch = false;
            stopwatch.Restart();
        }
        if (longPressWatch.ElapsedMilliseconds > 200)
        {
            Console.WriteLine("Long touch");
            HandleFlagClick(tile);
        }
        else
        {
            HandleRegularClick(tile);
        }
    }

    private void OnClick(MouseEventArgs e, TileProperty tile)
    {
        if (gameOver || tile.IsRevealed || lastEventWasTouch)
        {
            lastEventWasTouch = false;
            return;
        }

        Console.WriteLine("Normal click");

        if (firstTouch)
        {
            firstTouch = false;
            stopwatch.Restart();
        }

        if (e.Button == 2)
        {
            HandleFlagClick(tile);
        }
        else
        {
            HandleRegularClick(tile);
        }
    }

    // Long touch-screen press and right click
    private void HandleFlagClick(TileProperty tile)
    {
        if (tile.IsFlagged)
        {
            tile.IsFlagged = false;
            remainingMines++;
        }
        else
        {
            tile.IsFlagged = true;
            remainingMines--;
        }
    }

    // Regular touch and left click
    private void HandleRegularClick(TileProperty tile)
    {
        if (tile.IsFlagged)
        {
            return;
        }
        tile.IsRevealed = true;
        if (tile.IsBomb)
        {
            gameOver = true;
            stopwatch.Stop();
            RevealAllBombs();
            message = "You lost :(";
            return;
        }

        if (tile.SurroundingCount == 0)
        {
            RevealAllSurrounding(tile);
        }

        revealedSuccess++;
        if (revealedSuccess == revealedToWin)
        {
            stopwatch.Stop();
            message = "Victory!";
            gameOver = true;
        }
    }

    private void RevealAllBombs()
    {
        for (int i = 0; i < tiles.Length; i++)
        {
            for (int j = 0; j < tiles[i].Length; j++)
            {
                if (tiles[i][j].IsBomb)
                {
                    tiles[i][j].IsRevealed = true;
                }
            }
        }
    }

    private int CountNeighboringBombs(TileProperty tile)
    {
        int total = 0;

        for (int xoff = -1; xoff <= 1; xoff++)
        {
            for (int yoff = -1; yoff <= 1; yoff++)
            {
                var i = tile.Row + xoff;
                var j = tile.Col + yoff;
                if (i > -1 && i < gridSize && j > -1 && j < gridSize)
                {
                    var neighbor = tiles[i][j];
                    if (neighbor.IsBomb)
                    {
                        total++;
                    }
                }
            }
        }

        return total;
    }

    private void RevealAllSurrounding(TileProperty tile)
    {
        for (int xoff = -1; xoff <= 1; xoff++)
        {
            for (int yoff = -1; yoff <= 1; yoff++)
            {
                var i = tile.Row + xoff;
                var j = tile.Col + yoff;
                if (i > -1 && i < gridSize && j > -1 && j < gridSize)
                {
                    var neighbor = tiles[i][j];
                    if (neighbor.IsRevealed)
                    {
                        continue;
                    }
                    neighbor.IsRevealed = true;
                    revealedSuccess++;
                    if (neighbor.SurroundingCount == 0)
                    {
                        RevealAllSurrounding(neighbor);
                    }
                }
            }
        }
    }
}
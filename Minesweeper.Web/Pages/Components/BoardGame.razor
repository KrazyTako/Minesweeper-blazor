@using System.Diagnostics
@using System.Timers
@inject VibrationService vibrationService

<div oncontextmenu="return false" class="@sweeperClassMines disable-text-highlight overflow-auto minesweeper">
    @for (int i = 0; i < tiles?.Length; i++)
    {
        int row = i;
        <div class="row no-gutters flex-nowrap">
            @for (int j = 0; j < tiles[i].Length; j++)
            {
                int col = j;
                TileProperty tile = tiles[i][j];
                <div class="col tile" @ontouchstart="TouchStart" @ontouchmove="() => lastEventWasTouchMove = true" @ontouchend="(e) => TouchEnd(e, tile)" @onmouseup="(e) => OnClick(e, tile)">
                    <div class="tile-content @tile.CssClass ">
                        <span class="@tile.CssIcon">
                            @(tile.IsRevealed && string.IsNullOrEmpty(tile.CssIcon) ? (tile.SurroundingCount == 0 ? "" : tile.SurroundingCount.ToString()) : "")
                        </span>
                    </div>
                </div>
            }
        </div>
    }
</div>

@code {
    [Parameter]
    public EventCallback OnGameWinCallback { get; set; }

    [Parameter]
    public EventCallback OnGameLoseCallback { get; set; }

    [Parameter]
    public EventCallback<bool> OnFlagSetCallback { get; set; }

    [Parameter]
    public EventCallback<bool> OnFirstActionCallback { get; set; }

    private int _rows = 9;
    private int _columns = 9;
    private int totalMines = 10;
    private bool gameOver = false;
    private bool firstTouch = true;
    private int revealedSuccess;
    private int revealedToWin;
    private bool lastEventWasTouch;
    private bool lastEventWasTouchMove;

    private TileProperty[][] tiles;
    private Random generator = new Random();
    private Stopwatch longPressWatch = new Stopwatch();
    private Timer timer = new Timer(200);
    private string sweeperClassMines = "minesweeper-12";

    protected override void OnInitialized()
    {
        base.OnInitialized();
        timer.Elapsed += doVibration;
        Reset(_rows, _columns, totalMines);
    }

    public void Reset(int rows, int columns, int mines)
    {
        switch (columns)
        {
            case var n when n <= 12:
                sweeperClassMines = "minesweeper-12";
                break;
            case var k when k <= 16:
                sweeperClassMines = "minesweeper-16";
                break;
            case var i when i <= 20:
                sweeperClassMines = "minesweeper-20";
                break;
            default:
                sweeperClassMines = "minesweeper-30";
                break;
        }
        _rows = rows;
        _columns = columns;
        totalMines = mines;
        gameOver = false;
        firstTouch = true;
        revealedSuccess = 0;
        revealedToWin = (rows * columns) - totalMines;

        tiles = new TileProperty[_rows][];
        for (int i = 0; i < tiles.Length; i++)
        {
            tiles[i] = new TileProperty[_columns];
            for (int j = 0; j < tiles[i].Length; j++)
            {
                tiles[i][j] = new TileProperty();
                tiles[i][j].Row = i;
                tiles[i][j].Col = j;
            }
        }

        int count = 0;
        while (count < totalMines)
        {
            int randomRow = generator.Next(0, _rows);
            int randomCol = generator.Next(0, _columns);
            TileProperty tile = tiles[randomRow][randomCol];

            if (!tile.IsBomb)
            {
                tile.IsBomb = true;
                count++;
            }
        }

        bool markedFirstHelper = false;
        while (!markedFirstHelper)
        {
            int randomRow = generator.Next(0, _rows);
            int randomCol = generator.Next(0, _columns);
            TileProperty tile = tiles[randomRow][randomCol];

            if (!tile.IsBomb)
            {
                markedFirstHelper = true;
                tile.IsFirstHelper = true;
            }
        }

        for (int i = 0; i < tiles.Length; i++)
        {
            for (int j = 0; j < tiles[i].Length; j++)
            {
                var tile = tiles[i][j];
                tile.SurroundingCount = CountNeighboringBombs(tile);
            }
        }
    }

    private void TouchStart(TouchEventArgs e)
    {
        longPressWatch.Restart();
        lastEventWasTouch = true;
        timer.Start();
    }

    private void doVibration(Object source, System.Timers.ElapsedEventArgs e)
    {
        timer.Stop();
        if (lastEventWasTouchMove)
        {
            return;
        }
        vibrationService.VibrateAsync(100);
    }

    private async Task TouchEnd(TouchEventArgs e, TileProperty tile)
    {
        timer.Stop();
        longPressWatch.Stop();
        if (gameOver || lastEventWasTouchMove)
        {
            lastEventWasTouchMove = false;
            return;
        }

        if (firstTouch)
        {
            firstTouch = false;
            await OnFirstActionCallback.InvokeAsync(true);
        }

        if (longPressWatch.ElapsedMilliseconds > 200)
        {
            await HandleFlagClick(tile);
        }
        else
        {
            if(tile.IsRevealed)
            {
                await HandleChord(tile);
            }
            else
            {
                await HandleRegularClick(tile);
            }
        }

        if (revealedSuccess == revealedToWin)
        {
            gameOver = true;
            await OnGameWinCallback.InvokeAsync(1);
        }
    }

    private async Task OnClick(MouseEventArgs e, TileProperty tile)
    {

        if (gameOver || lastEventWasTouch)
        {
            lastEventWasTouch = false;
            return;
        }

        if (firstTouch)
        {
            firstTouch = false;
            await OnFirstActionCallback.InvokeAsync(true);
        }

        if (e.Button == 2)
        {
            await HandleFlagClick(tile);
        }
        else if (e.Button == 0)
        {
            if (tile.IsRevealed)
            {
                await HandleChord(tile);
            }
            else
            {
                await HandleRegularClick(tile);
            }
        }

        if (revealedSuccess == revealedToWin)
        {
            gameOver = true;
            await OnGameWinCallback.InvokeAsync(1);
        }
    }

    private Task HandleChord(TileProperty tile)
    {
        // Count surrounding flags
        int surroundingFlags = 0;
        for (int xoff = -1; xoff <= 1; xoff++)
        {
            for (int yoff = -1; yoff <= 1; yoff++)
            {
                var i = tile.Row + xoff;
                var j = tile.Col + yoff;
                if (i > -1 && i < _rows && j > -1 && j < _columns)
                {
                    var neighbor = tiles[i][j];
                    if (neighbor.IsFlagged)
                    {
                        surroundingFlags++;
                    }
                }
            }
        }

        // Make sure its equal to the surrounding count, otherwise ignore this action
        if (surroundingFlags == tile.SurroundingCount)
        {
            for (int xoff = -1; xoff <= 1; xoff++)
            {
                for (int yoff = -1; yoff <= 1; yoff++)
                {
                    var i = tile.Row + xoff;
                    var j = tile.Col + yoff;
                    if (i > -1 && i < _rows && j > -1 && j < _columns)
                    {
                        var neighbor = tiles[i][j];
                        if (!neighbor.IsFlagged && !neighbor.IsRevealed)
                        {
                            neighbor.IsRevealed = true;
                            if (neighbor.IsBomb)
                            {
                                gameOver = true;
                                RevealAllBombs();
                                return OnGameLoseCallback.InvokeAsync(1);
                            }
                            if (neighbor.SurroundingCount == 0)
                            {
                                RevealAllSurrounding(neighbor);
                            }
                            revealedSuccess++;
                        }
                    }
                }
            }
        }
        return Task.CompletedTask;
    }

    // Long touch-screen press and right click
    private async Task HandleFlagClick(TileProperty tile)
    {
        if (!tile.IsRevealed)
        {
            tile.IsFlagged = !tile.IsFlagged;
            await OnFlagSetCallback.InvokeAsync(tile.IsFlagged);
        }
    }

    // Regular touch and left click
    private async Task HandleRegularClick(TileProperty tile)
    {
        if (tile.IsFlagged || tile.IsRevealed)
        {
            return;
        }
        tile.IsRevealed = true;
        if (tile.IsBomb)
        {
            gameOver = true;
            RevealAllBombs();
            await OnGameLoseCallback.InvokeAsync(1);
            return;
        }

        if (tile.SurroundingCount == 0)
        {
            RevealAllSurrounding(tile);
        }
        revealedSuccess++;
    }

    private void RevealAllBombs()
    {
        for (int i = 0; i < tiles.Length; i++)
        {
            for (int j = 0; j < tiles[i].Length; j++)
            {
                if (tiles[i][j].IsBomb)
                {
                    tiles[i][j].IsRevealed = true;
                }
            }
        }
    }

    private int CountNeighboringBombs(TileProperty tile)
    {
        int total = 0;

        for (int xoff = -1; xoff <= 1; xoff++)
        {
            for (int yoff = -1; yoff <= 1; yoff++)
            {
                var i = tile.Row + xoff;
                var j = tile.Col + yoff;
                if (i > -1 && i < _rows && j > -1 && j < _columns)
                {
                    var neighbor = tiles[i][j];
                    if (neighbor.IsBomb)
                    {
                        total++;
                    }
                }
            }
        }

        return total;
    }

    private void RevealAllSurrounding(TileProperty tile)
    {
        for (int xoff = -1; xoff <= 1; xoff++)
        {
            for (int yoff = -1; yoff <= 1; yoff++)
            {
                var i = tile.Row + xoff;
                var j = tile.Col + yoff;
                if (i > -1 && i < _rows && j > -1 && j < _columns)
                {
                    var neighbor = tiles[i][j];
                    if (neighbor.IsRevealed)
                    {
                        continue;
                    }
                    neighbor.IsRevealed = true;
                    revealedSuccess++;
                    if (neighbor.SurroundingCount == 0)
                    {
                        RevealAllSurrounding(neighbor);
                    }
                }
            }
        }
    }
}
